---
title: "[번역] 리덕스 스타일 가이드"
date: "2020-03-22 14:14:15"
template: "post"
draft: true
slug: "번역-리덕스-스타일-가이드"
category: "architecture"
tags:
  - "Redux"
description: "공식문서에서 권장하는 리덕스 설계를 배워보자."
---

# 리덕스 스타일 가이드

## 소개

이 문서는 리덕스 코드를 작성하는 공식적인 스타일 가이드이다. **우리가 추천하는 패턴과 최선의 방식 및 리덕스 어플리케이션을 만드는 접근법들을 나열한다.**

리덕스의 코어 라이브러리와 대부분의 리덕스 문서에는 그리 의견이 많지 않다. 리덕스를 사용하는 방법은 굉장히 많았지만 많은 시간 동안 "올바르게" 사용하는 방법은 없었다.

그러나, 몇몇 주제들에 대해서 시간과 경험이, 특정한 접근방법들이 다른 것들보다 더 낫다는 것을 보여주었다. 덧붙여서, 많은 개발자들이 설계에 힘을 들이지 않도록 공식적인 가이드를 제공해달라고 요청해왔다.

이를 염두에 두고, **우리는 에러와 쓸데없는 시간 낭비 및 안티-패턴들을 피하기 위해 권장사항들을 모았다.** 우리는 또한 각 팀의 선호사항이 다르고 다른 프로젝트들이 각각 다른 요구조건들이 있기 때문에 모든 것에 적합한 스타일 가이드는 없는 것을 알고 있다. **따라서, 권장사항들을 따르기를 장려하지만, 자신의 상황을 잘 파악해서 이것들이 필요사항에 맞는지 정하는 시간을 가져야 할 것이다.**

마지막으로, 이 페이지를 만드는에 영감을 주었던 [뷰 스타일 가이드](https://vuejs.org/v2/style-guide/)의 작성자들에게 고마움을 표한다.



## 규칙 카테고리

규칙을 3가지 카테고리로 나누었다.

### 우선순위 A: 필수

**이 규칙들은 에러를 방지하는데 도움이 되므로, 학습비용을 감수하더라도 꼭 배워야 한다.** 예외사항이 있을 수 있지만, 그런 경우는 매우 드물어야 하며 자바스크립트와 리덕스에 전문적인 지식을 가진 사람에 의해서만 이루어져야 한다.

### 우선순위 B: 강력 추천

이 규칙들은 대부분의 프로젝트에서 가독성 및/또는 개발자의 경험을 개선시켜왔다. 규칙을 위반해도 코드는 동작하겠지만, 위반하는 경우가 드물어야 하며 그 위반사유가 잘 정당화되어야 한다. **합리적으로 가능하다면 이 규칙을 따르도록 하라.**

### 우선순위 C: 권장

여러개의 동일하게 좋은 옵션들이 있다면, 일관성을 유지하기 위해 아무거나 선택해도 된다. 이 규칙들에서, 각각의 가능한 옵션들을 설명하고 기본적인 선택을 제안한다. 이 말은 즉, 코드를 짤 때 일관적이며 합당한 이유를 갖고 있다면 다른 선택을 해도 상관없다는 뜻이다. 그래도 좋은 이유가 있는 것이 좋다!



## 우선순위 A의 규칙: 필수

### 상태를 바꾸지 마시오.

상태를 바꾸는 행위는 리덕스 어플리케이션에서 발생하는 가장 흔한 버그 중 하나로, 컴포넌트로 하여금 다시 렌더링 되는 것을 막거나 리덕스 개발자 도구에서의 시간여행(time-travel) 디버깅을 고장낼 수 있다. 리듀서들과 모든 다른 코드에서 **상태 값의 직접적인 변경은 반드시 피해야 한다.**

개발하는 동안, 상태변화를 감지하기 위해 [`redux-immutable-state-invariant`](https://github.com/leoasis/redux-immutable-state-invariant) 를 사용하고 우연한 상태변경을 막기 위해 [Immer](https://immerjs.github.io/immer/docs/introduction) 를 사용하라.

> **참고** : *복사한 값* 을 변경하는 것은 괜찮다 - 변경불가능한 업데이트 로직의 일반적인 경우이다. 또한, Immer 라이브러리를 사용하고 있다면, 실제 값은 변경되지 않기 때문에 "변경하는" 로직을 작성해도 괜찮다 - Immer가 안전하게 변화를 추적하고 내부에서 변경불가능하게 업데이트된 값들을 만들어낸다.

### 리듀서들은 부수효과를 가지면 안된다.

리듀서의 함수들은 *오직* 그것들의 `state` 와 `action` 인자들에만 의존해야 하고 그 인자들을 기반으로 계산한 새로운 상태만을 반환해야 한다. **그것들은 절대로 비동기 로직(Ajax 호출, 타임아웃, Promises 등), 랜덤 값 생성(`Date.now()`, `Math.random()`), 리듀서 밖의 값 변경, 또는 리듀서 함수의 외부 스코프에 있는 것들을 변경할 수 있는 코드를 실행해서는 안된다.**

> **참고** : 리듀서가 외부에 있는 함수들을 호출하는 것은 가능한데 예를 들어, 유틸리티 함수들이나 라이브러리로 가져온 경우이다. 물론, 이것들도 같은 규칙을 따르는 한해서이다.

<details markdown="1">
  <summary style="font-weight: bold;">자세한 설명</summary>
  이 규칙의 목적은 리듀서로 하여금 호출됬을 때 예측가능하게 만들기 위함이다. 예를 들어, 당신이 시간여행 디버깅을 하고 있다고 하면, 리듀서 함수들은 "현재" 상태 값들을 만들어내도록 이전 액션들과 함께 여러번 호출될 수 있다. 만약 리듀서가 부수효과를 가진다면, 디버깅 할 동안 그런 효과들이 발생할 수 있고 어플리케이션으로 하여금 예상못한 결과를 만들어내게 된다.<br/>
  이 규칙에 대한 회색 영역이 존재한다. 엄밀히 말하자면, <code>console.log(state)</code> 와 같은 코드는 부수 효과이지만 실제로 어플리케이션의 동작방식에 아무런 영향을 주지 않는다.
</details>


### 직렬화-불가능한 값들을 상태나 액션에 넣지 마시오.

**Promises, Symbols, Maps/Sets, 함수들, 또는 클래스 인스턴스와 같은 직렬화-불가능한 것들을 리덕스 스토어의 상태나 디스패치되는 액션에 넣는 것을 피하라.** 이것은 리덕스 개발자 도구로 디버깅하는 것과 같은 기능이 제대로 동작하게 한다. 또한 UI도 예상한 것처럼 업데이트되게 한다.

> **예외** : 리듀서에 도달하기 전, 액션을 미들웨어가 가로채서 중지시킨다면, 직렬화-불가능한 값들을 액션에 넣을수 있다. 예를 들어, `redux-thunk` 나 `redux-promise` 같은 것들이 있다.

### 하나의 어플리케이션에는 오직 하나의 리덕스 스토어

**표준 리덕스 어플리케이션은 오직 하나의 리덕스 스토어 인스턴스를 가져야 하며 이는 어플리케이션 전체에서 사용된다.** 일반적으로 `store.js` 와 같은 별도의 파일에 정의되어야 한다.

이상적으로, 로직 중에서 스토어를 직접적으로 가져오는 경우는 없다. `<Provider>` 를 통해서 리액트 컴포넌트 트리로 전달되거나 thunk와 같은 미들웨어를 통해 간접적으로 참조되어야 한다. 드물게, 다른 로직 파일에서 가져올 수 있지만, 최후의 수단이어야 한다.



## 우선순위 B의 규칙: 강력 추천

### 리덕스 로직을 작성하는데 Redux Toolkit을 사용하자.

[Redux Toolkit](https://redux.js.org/redux-toolkit/overview) 은 리덕스 사용을 위해 추천하는 도구세트이다. 우리가 제안한 최선의 방법들을 사용하는 함수들을 가지고 있으며 상태변화를 감지하도록 스토어를 설정하고 리덕스 개발자 도구 사용을 가능하게 할 뿐 아니라, Immer를 사용하여 변경불가능한 업데이트 로직을 단순화하는 등의 여러가지 유용한 기능들을 가지고 있다.

RTK(Redux ToolKit)가 필요없을 수도 있고, 다른 접근법들이 바람직하다면 그것들을 사용해도 상관없지만 **RTK를 사용하는 것이 당신의 로직을 단순하게 만들고 어플리케이션으로 하여금 좋은 설정을 기본으로 가지도록 보장해줄 것이다.**

### 변경불가능한 업데이트를 하는데 Immer를 사용하자.

변경불가능한 업데이트 로직을 손수 작성하는 것은 항상 어렵고 에러가 발생할 여지가 있다. [Immer](https://immerjs.github.io/immer/docs/introduction) 는 "변화되는" 로직을 사용해서 간단하게 변경불가능한 로직을 작성하도록 해주고, 심지어 개발중에 어플리케이션 어디에서나 상태변화를 감지하도록 상태를 얼린다(freeze). 변경불가능한 업데이트 로직을 작성하는데 **[Redux Toolkit](https://redux.js.org/redux-toolkit/overview) 의 한 부분으로 Immer를 사용하는 것을 추천한다.**

### Feature/Ducks 폴더로 파일을 구조화하자.

리덕스 그 자체는 어플리케이션의 폴더나 파일이 어떻게 구조화하는지에 관여하지 않는다. 그러나, 주어진 특징에 대해 동일한 로직들잉 한곳에 위치하도록 하는 것은 코드를 보다 쉽게 유지보수하게 만들어준다.

이러한 이유로, 대부분의 어플리케이션들이 코드의 "타입" (리듀서, 액션 등)에 따라 폴더를 만들어 로직을 분리하기 보다 **"feature 폴더" 접근법이나 (특징에 대한 모든 파일들을 하나의 폴더에 넣는 것) ["ducks" 패턴](https://github.com/erikras/ducks-modular-redux) (하나의 파일에 특징에 대한 모든 리덕스 로직을 넣는 것) 을 사용해서 파일들을 구조화하는 것을 추천한다.**

<details markdown="1">
  <summary style="font-weight: bold;">자세한 설명</summary>
  폴더구조의 예시는 다음과 같을 것이다.
  <ul>
    <li>
      <code>/src</code>
      <ul>
        <li><code>index.tsx</code></li>
        <li>
          <code>/app</code>
          <ul>
           	<li><code>store.ts</code></li>
           	<li><code>rootReducer.ts</code></li>
           	<li><code>App.tsx</code></li>
          </ul>
        </li>
        <li>
          <code>/common</code>
          <ul>
            <li>훅, 포괄적인 컴포넌트, 유틸 등</li>
          </ul>
        </li>
        <li>
        	<code>/features</code>
          <ul>
            <li>
              <code>/todos</code>
              <ul>
                <li>todosSlice.ts</li>
                <li>Todos.tsx</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <code>/app</code>은 앱 전체적인 설정과 다른 폴더들에 의존하는 설계를 포함한다.<br/>
  <code>/common</code>은 포괄적이거나 재사용 가능한 유틸 및 컴포넌트를 포함한다.<br/>
  <code>/features</code>는 특정 기능과 관련된 모든 기능들을 포함한 폴더를 가진다. 이 예시에서, <code>todosSlice.ts</code>는 "duck"-스타일의 파일이며 여기서 RTK의 <code>createSlice()</code> 함수를 호출하고 이로 인해 생성된 리듀서와 액션 생성자를 내보낸다.
</details>


### 리듀서에 가능한 많은 로직을 넣자.

가능하면 **새로운 상태를 계산하는 로직을, 액션을 준비하고 디스패치하는 코드 (클릭 핸들러와 같은) 가 아니라 해당 로직에 적합한 리듀서에 많이 넣도록 하자.** 이것은 대부분의 어플리케이션 로직들이 쉽게 테스트 가능하도록 해주며, 시간여행 디버깅을 보다 효과적으로 도와주고 변경이나 버그로 이어질 수 있는 흔한 실수들을 방지하는데 도움이 된다.

새로운 상태 전체 또는 일부가 먼저 계산되어야 하는 경우 (유일무이한 아이디 값을 생성해내는 경우와 같은) 가 있긴 하지만 최소한으로 지켜줘야 한다.

#### 자세한 설명

리덕스 코어는 새로운 상태 값이 리듀서 안에서 계산되는지 아니면 액션 생성 로직 안에서 계산되는지에는 신경쓰지 않는다. 예를들어, 할일목록 앱의 경우, "할일 토글" 액션을 위한 로직은 할일목록의 배열을 변경불가능하게 업데이트하는 것을 요구한다. 액션이 todo ID만을 포함하고 리듀서 안에서 새로운 배열을 계산해도 된다.

```javascript
// 클릭 핸들러:
const onTodoClicked = (id) => {
    dispatch({type: "todos/toggleTodo", payload: {id}})
}

// 리듀서:
case "todos/toggleTodo": {
    return state.map(todo => {
        if(todo.id !== action.payload.id) return todo;

        return {...todo, id: action.payload.id};
    })
}
```

또한 새로운 배열을 먼저 계산해서 전체배열을 액션에 넣어도 된다.

```javascript
// 클릭 핸들러:
const onTodoClicked = id => {
  const newTodos = todos.map(todo => {
    if (todo.id !== id) return todo

    return { ...todo, id }
  })

  dispatch({ type: 'todos/toggleTodo', payload: { todos: newTodos } })
}

// 리듀서:
case "todos/toggleTodo":
    return action.payload.todos;
```

그러나, 여러가지 이유로 리듀서안에서 로직을 수행하는 것이 바람직하다:

* 리듀서는 순수함수이기 때문에 항상 테스트하기가 쉽다 - `const result = reducer(testState, action)` 만 호출하면 되고, 결과를 원하는 값으로 단언(assert)하면 된다. 따라서, 리듀서 안에 로직을 많이 넣을 수록, 테스트하기 쉬운 로직이 많아지는 것이다.
* 리덕스의 상태는 항상 [변경불가능한 업데이트 규칙](https://redux.js.org/recipes/structuring-reducers/immutable-update-patterns) 을 따라야 한다. 대부분의 리덕스 사용자들은 리듀서 안에서 해당 규칙들을 따라야 하는 것은 알지만, 새로운 상태가 리듀서 *밖에서* 계산될 경우에 *또한* 이 규칙들을 따라야 하는지는 명확하지 않다. 이것은 우연찮은 상태변경이나, 심지어는 리덕스 스토어에서 값을 읽어서 액션 안에 바로 전달하는 것과 같은 실수로 이어지기 쉽다. 리듀서안에서 모든 상태변경 로직을 수행하는 것은 이런 실수들을 방지시킨다.
* Redux Toolkit 또는 Immer를 사용한다면, 리듀서 안에서 변경불가능한 업데이트 로직을 작성하기 쉽고 Immer는 상태를 얼릴뿐만 아니라 우연한 상태변경을 잡아낼 것이다.
* 시간여행 디버깅은 디스패치된 액션을 "실행 취소" 하고 다른 작업들을 하거나 그 액션을 "다시 실행" 하는 것으로 동작한다. 또한, 리듀서들의 핫-리로딩(hot-reloading)은 기존의 액션들로 새로운 리듀서를 재실행하는 것을 포함한다. 올바른 액션을 가졌지만 리듀서에 버그가 있다면, 리듀서의 버그를 고치고 핫-리로드를 해서 제대로된 상태값을 얻어낼 수 있다. 액션 자체가 잘못되었다면, 액션이 디스패치되는 단계를 다시 실행하여야 한다. 따라서, 리듀서에 더 많은 로직이 있는 것이 디버깅 하기 쉬운것이다.
* 마지막으로, 리듀서안에 로직을 넣으면 전체 코드에 로직이 퍼지는 대신 업데이트 로직이 어디있는지 바로 알 수 있다.

### 리듀서는 자신만의 상태모양을 가져야 한다.

리덕스의 루트 상태는 루트 리듀서 함수 1개에 의해 소유되고 계산된다. 유지보수를 위해, 그 리듀서는 키/값의 "슬라이스(slices)"로 쪼개지는데, 각각의 "슬라이스 리듀서"는 초기값을 제공하고 해당 상태에 대한 업데이트를 계산한다.

또한, 슬라이스 리듀서는 계산된 상태의 일부로 반환되는 값들을 제어해야 한다. `return action.payload` 와 `return {...state, ...action.payload}` 와 같은 "보이지 않는 spread 및 리턴"의 사용을 최소화해야 하는데 그 이유는, 이것들이 컨텐츠를 올바른 포맷으로 수정하기 위해 액션을 디스패치하는 코드에 의존하고, 리듀서는 상태가 어떻게 생겼는지에 대한 소유권을 포기하기 때문이다. 액션의 컨텐츠가 잘못되었다면 이는 버그로 이어질 수 있다.

> **참고** : "spread 리턴" 리듀서는 폼의 데이터를 수정하는 것과 같은 경우에 합리적인 선택이 될 수 있는데, 폼의 각 필드에 대해 별도의 액션 타입을 작성하는 것은 시간낭비가 될 수 있고 별로 이득이 없기 때문이다.

### 자세한 설명

"현재 사용자" 리듀서가 아래와 같이 생겼다고 하자:

```javascript
const initialState = {
    firstName: null,
    lastName: null,
    age: null,
};

export default usersReducer = (state = initialState, action) {
    switch(action.type) {
        case "users/userLoggedIn": {
            return action.payload;
        }
        default: return state;
    }
}
```

이 예시에서, 리듀서는 완전히 `action.payload` 가 올바른 포맷을 가진 객체라고 가정한다. 그러나, 코드 일부분이 "사용자" 객체가 아니라 "할일" 객체를 액션에 넣어 디스패치했다고 해보자.

```javascript
dispatch({
  type: 'users/userLoggedIn',
  payload: {
    id: 42,
    text: 'Buy milk'
  }
})
```

리듀서는 보이지 않게 "할일"을 반환할 것이고, 앱의 나머지 부분은 스토어에서 "사용자"를 가져오려 할 때 망가질 것이다. `action.payload` 가 올바른 필드를 가졌는지 유효성 체크를 한다거나 이름을 사용해서 올바른 필드를 읽는 등의 방법을 사용한다면 적어도 부분적으로는 고칠 수 있을 것이다. 하지만 이러한 방법은 코드를 더 추가하기 때문에 안전함과 간단함 사이에서 어떤 것을 선택해야 할지 이율배반(trade-off)을 고민하게 된다. 정적 타이핑을 사용한다면 이러한 종류의 코드를 더욱 안전하고 보다 수용가능하게 만든다. 만약 리듀서가 `action` 이 `PayloadAction<User>` 라는 것을 안다면, `return action.payload` 는 *안전할 수밖에 없다.*

### 스토어의 데이터 기반으로 상태 슬라이스 이름을 짓자.

[리듀서는 자신만의 상태모양을 가져야 한다](#리듀서는-자신만의-상태모양을-가져야-한다) 에서 말했던 것처럼, 리듀서 로직을 분리하는 표준 접근방식은 상태의 "슬라이스(slices)" 기반이다. 동일하게, `combineReducers` 는 이러한 슬라이스 리듀서들을 하나의 거대한 리듀서 함수로 합치는 표준함수이다.

`combineReducers` 에 넘겨지는 객체의 키 이름은 결과적으로 나올 상태 객체의 키 이름을 정의한다. 데이터가 내부에 보관된 이후에 키 이름을 지정하도록 하고, "reducer" 와 같은 이름은 피하자. 객체는 `{userReducer: {}, postsReducer: {}}` 보다 `{users: {}, posts: {}}` 같이 생겨야 한다.

#### 자세한 설명

ES6 객체 리터럴은 키 이름과 값을 한번에 정의하는 단축기능을 제공한다:

```javascript
const data = 42;
const obj = { data }
// {data: data}와 같다.
```

`combineReducers` 는 리듀서 함수가 모두 들어있는 객체를 받고 키 이름과 동일한 상태 객체들을 생성한다. 함수 객체의 키 이름이 상태 객체의 키 이름을 정의한다는 것을 의미한다. 이것은 리듀서를 "reducer"와 같은 변수이름으로 가져와서 객체 리터럴 단축기능을 사용하여 `combineReducers` 에게 넘기는 실수를 발생시킨다.

```javascript
import usersReducer from 'features/users/usersSlice'

const rootReducer = combineReducers({
  usersReducer
})
```

이 경우에, 객체 리터럴 단축기능은 `{usersReducer: usersReducer}` 와 같은 객체를 만든다. 따라서, "reducer"는 상태객체의 키 이름이 된다. 이것은 중복이고 쓸모가 없다. 대신에, 안에 있는 데이터에만 관련있도록 이름을 정의하자. 우리는 명시적으로 `key: value` 문법을 사용하는 것을 제안한다.

```javascript
import usersReducer from 'features/users/usersSlice'
import postsReducer from 'features/posts/postsSlice'

const rootReducer = combineReducers({
  users: usersReducer,
  posts: postsReducer
})
```

코드를 더 치긴 하지만, 가장 이해하기 쉬운 코드와 상태 정의이다.

